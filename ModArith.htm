<!DOCTYPE html>
<html>
<head>
<title>Notes On Modular Arithmetic</title>

<style>
body {
  background-color: black;
}

h1 {text-align: center;
    color: white;}
h5 {text-align: center;
    color: white;}
p {text-align: left;
   color: white;}

</style>

</head>
<body>

<h1>Notes On Modular Arithmetic</h1>
<h5>Last updated September 12, 2023.<br>
Copyright &copy; Eric Chauvin 2022 - 2023.</h5>

<p>The basic type of large integers are
 in Integer.cpp and IntegerMath.cpp.  That has
 the basics like Addition, Subtraction,
 Multiplication, etc.  If you are new to
 working with large integers see Base10Number.cpp
 first.  Source code for the basic integers
 is in the
 <a href="https://github.com/EricsSourceCode/CppInt">
 CppInt repository</a>.
 Most of the CryptoGraphic source code is in the
 <a href="https://github.com/EricsSourceCode/CryptoBase">
 CryptoBase repository</a>.  Source files are
 sometimes named after mathematicians, so
 Euclid.cpp has the Euclidean algorithm for
 finding the Greatest Common Divisor.
 Fermat.cpp has the
 Fermat Primality test.  TonelliShanks.cpp has
 the Tonelli-Shanks algorithm for finding a
 modular square root.  Euler.cpp has the Euler
 Criterion.
</p>

<p>Modular arithmetic is done in the Mod.cpp
 file.  The basic textbook function to raise a
 number to an exponent is in the Mod.cpp file,
 in Mod::toPower().  It is the standard
 Square-and-Multiply function, except that
 it has been modified to use my Modular
 Reduction algorithm in NumbSys.cpp.
</p>

<p>When you are doing thousands of modular
 operations they don't have to be exact at
 intermediate stages.  If the modulus is N
 then an intermediate value can be something
 like Y times N plus some value.  The Y would
 be a relatively small number, typically less
 than a 32-bit integer, and you can divide it
 out at the end.  See the NumbSys.cpp file
 for that Modular Reduction algorithm.  You
 can see that reduction in Mod::toPower()
 where the reduce() function is used more than
 a thousand times for intermediate operations
 and then at the end it calls Mod::makeExact().
 That's an important general idea that applies
 when ever you have lots and lots of intermediate
 operations.
</p>

<p>In the Exponents::toPower() function, in the
 Exponents.cpp file, you can see where it
 calls setupBases() if the
 modulus or the base value has changed.  What
 that does is separate the Double from the
 Multiply in the Double-and-Multiply algorithm.
 If the base doesn't change then the Double part
 of the algorithm only has to be done once at
 the beginning.  Then you can change the exponent
 value as many times as you want, but leave the
 base part at the same value.
</p>


<p><a href="https://github.com/EricsSourceCode/">
Source Code</a>
</p>

<p><a href="https://EricsSourceCode.github.io/">
Main Page</a>
<br><br>
</p>

<br>

</body>
</html>
